# !/usr/bin/env python
# -*-coding:utf-8 -*-
# Time: 2025/12/15 12:22
# FileName: IntegratingDatabasesBYLangChain
# Project: LangchainStudy
# Author: JasonLai
# Email: jasonlaihj@163.com
"""
使用chain整合数据库，根据数据库数据，提问后直接生成想要的答案
Integrate the database using a chain, and directly generate the desired answer after asking questions based on the database data.
"""
import os
import re
import sys
import importlib

from langchain_core.tools import tool
from langchain_openai import ChatOpenAI
from langchain_core.prompts import PromptTemplate
from langchain_community.utilities import SQLDatabase
from langchain_core.runnables import RunnablePassthrough, RunnableLambda
from langchain_core.output_parsers import StrOutputParser
from langchain_community.tools import QuerySQLDatabaseTool
from langchain.chains.sql_database.query import create_sql_query_chain

from exts import OpenRouter_api_key

key_path = r"D:\Resource\keys\api_keys.py"
sys.path.append(os.path.dirname(key_path))
api_keys_name = os.path.basename(key_path).split('.')[0]
api_keys = importlib.import_module(api_keys_name)

"""
In Langchain, when using SQLAlchemy for connection, 
SQLAlchemy uses the function `create_engine` to generate a database engine object from the URL.
"""

username = api_keys.username
pw_mysql = api_keys.pw_mysql
port = '3306'
hostname = "127.0.0.1"
db_name = "test_db1"

# pymysql driver url
mysql_url = f"mysql+pymysql://{username}:{pw_mysql}@{hostname}:{port}/{db_name}?charset=utf8"

# 1.create a large model object
llm_obj = ChatOpenAI(
    model="amazon/nova-2-lite-v1:free",
    api_key=OpenRouter_api_key,
    base_url="https://openrouter.ai/api/v1",
    temperature=0.1,  # Lowering the temperature improves the stability of SQL generation
    timeout=30,
    max_retries=2,
)

# 2.Create a database using langchain
db = SQLDatabase.from_uri(
    mysql_url,
    include_tables=None,  # None表示包含所有表，也可指定具体表名列表
    sample_rows_in_table_info=3,  # 增加表的示例数据，帮助LLM理解数据格式
)

# Custom SQL generation prompt
sql_prompt = PromptTemplate.from_template("""
You are a professional MySQL SQL generation expert. Generate executable SQL strictly according to the following rules:
1. Table structure and sample data: {table_info}
2. The number of result rows does not exceed {top_k}
3. Only generate MySQL statements, no explanatory text, and the field/table names must match exactly
4. Handle null values and special characters to avoid syntax errors

User's question: {input}

Generated SQL statement:
""")

# 3.Create a chain for generating SQL operation statements
test_query_chain = create_sql_query_chain(
    llm=llm_obj,
    db=db,
    prompt=sql_prompt,
    k=5
)


# 4.create a prompt template
def clean_sql(sql: str) -> str:
    """Clean up irrelevant content in SQL generated by LLM (such as Markdown tags, explanatory text)"""
    # Remove markdown code block markers
    sql = re.sub(r"```sql|```", "", sql).strip()
    # Remove explanatory text, leaving only SQL statements
    sql_lines = []
    for line in sql.split("\n"):
        line = line.strip()
        if line and not line.lower().startswith(("--", "/*", "//")):
            sql_lines.append(line)
    return "\n".join(sql_lines)


@tool
def execute_sql_with_validate(sql: str) -> str:
    """Execute SQL, perform verification, and return structured results"""
    try:
        # Clean up SQL
        clean_sql_str = clean_sql(sql)
        if not clean_sql_str:
            return "The generated SQL is empty or invalid."

        # Execute SQL
        execute_tool = QuerySQLDatabaseTool(db=db)
        result_obj = execute_tool.run(clean_sql_str)

        # Handling empty results
        if result_obj == "[]" or result_obj == "":
            return "The query result is empty."

        return result_obj
    except Exception as e:
        # Return error messages to facilitate debugging
        return f"SQL execution failed：{str(e)}"


# 5.Optimize the prompt template for the final response.
prompt_tem = PromptTemplate.from_template("""
Answer concisely in short sentences based on the user's question, SQL statement, and execution result. 

Question: {question}
SQL Query: {query}
SQL Result: {result}

Answer:
""")

# 6. Integrate into a new chain
final_chain = (
        RunnablePassthrough().assign(

            # 生成SQL（使用清理后的输入） Generate SQL (using the cleaned input)
            query=lambda x: test_query_chain.invoke({
                # The underlying hardcoding of create_sql_query_chain requires that the Prompt must include the input variable as well as the question(regardless of whether you use it or not)
                "input": x["question"],
                "question": x["question"],
            })
        ).assign(
            # 执行SQL（带校验） Execute SQL (with verification)
            result=lambda x: execute_sql_with_validate.run(x["query"])
        )
        | prompt_tem
        | llm_obj
        | StrOutputParser()
)


# 7.test function
def test_chain(question: str) -> str:
    """Test the execution result of the Chain"""
    try:
        res = final_chain.invoke({"question": question})
        return res
    except KeyError as e:
        return f"Variable error: Missing key {e}, please check the variable passing logic"
    except Exception as e:
        return f"Chain execution failed：{str(e)}"


# Example call
if __name__ == "__main__":
    # Replace with your actual test question
    test_question = "How many pieces of data are there in the users_langchain table?"
    result = test_chain(test_question)
    print("Final answer：", result)
    # mysql> select * from users_langchain;
    # +----+-------+--------+-----+-----------------------+-----------------------------------+
    # | id | name  | gender | age | job                   | hobby                             |
    # +----+-------+--------+-----+-----------------------+-----------------------------------+
    # |  1 | jason | 男     |  34 | RPA开发工程师         | 旅游，越野创越                    |
    # |  2 | jack  | 男     |  33 | 销售经理              | 打蓝球                            |
    # |  3 | awen  | 男     |  27 | 后端开发工程师        | 炒股                              |
    # |  4 | hda   | 女     |  23 | 主播                  | 直播                              |
    # |  5 | dhudh | 女     |  26 | 户外博主              | 穿越无人区，机车，驾驶            |
    # +----+-------+--------+-----+-----------------------+-----------------------------------+
    # Result as the follow:
    # Final answer： Answer: There are **5** pieces of data in the users_langchain table


